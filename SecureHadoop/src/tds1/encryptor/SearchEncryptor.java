package tds1.encryptor;

import java.io.IOException;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.conf.Configured;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.BytesWritable;
import org.apache.hadoop.io.LongWritable;
import org.apache.hadoop.io.NullWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;
import org.apache.hadoop.mapreduce.lib.output.SequenceFileOutputFormat;
import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
import org.apache.hadoop.mapreduce.lib.input.SequenceFileInputFormat;
import org.apache.hadoop.mapreduce.lib.input.TextInputFormat;
import org.apache.hadoop.mapreduce.Job;
import org.apache.hadoop.mapreduce.Mapper;
import org.apache.hadoop.util.Tool;
import org.apache.hadoop.util.ToolRunner;
import org.apache.log4j.Logger;


import crypto.Det;
import crypto.Searchable;


/**
 * @author dinhtta
 * 
 * Read the SequenceInputFile<NullWritable, Text> generated by RandomTextWriter, and encrypt the words
 * individually. The output is another SequenceOutputFil<NullWritable, BytesWritable> 
 * 
 * -D encryption_mode=line/word
 *
 */
public class SearchEncryptor extends Configured implements Tool{

	static int AES_BLOCK_SIZE=16;
	enum EncryptionCounter{
		CIPHERTEXT_BYTES,
		OBJECT_BYTES
	}
	
	@Override
	public int run(String[] arg0) throws Exception {
		Configuration conf = this.getConf();  		
		Job job = new Job(conf); 
		
		job.setJobName("searchable encryptor"); 
		job.setJarByClass(SearchEncryptor.class); 
		FileInputFormat.addInputPath(job, new Path(arg0[0])); 
		FileOutputFormat.setOutputPath(job, new Path(arg0[1])); 
		
		//job.setInputFormatClass(TextInputFormat.class); 
		job.setMapperClass(SearchEncryptorMapper.class);
		job.setOutputKeyClass(NullWritable.class); 
		job.setOutputValueClass(BytesWritable.class); 
		
		job.setOutputFormatClass(SequenceFileOutputFormat.class); 
		job.setNumReduceTasks(0); 
		
		return job.waitForCompletion(true)?0:1; 		
	}

	public static void main(String[] args) throws Exception{
		ToolRunner.run(new Configuration(), new SearchEncryptor(), args); 
	}
}

class SearchEncryptorMapper extends Mapper<LongWritable, Text, NullWritable, BytesWritable>{
	private Searchable crypto; 
	
	
	static Logger log = Logger.getLogger(SearchEncryptorMapper.class);
	static boolean MODE_WORD=true; 
	@Override
	public void setup(Context context){
		Configuration conf = context.getConfiguration();	
		log.info("encryption mode = "+conf.get("encryption_mode")+" key = "+conf.get("key")+" iv = "+conf.get("iv")); 
		
		if (conf.get("encryption_mode").equals("line"))
			MODE_WORD=false; 
		
		crypto = new Searchable(); 			
		crypto.init(conf.get("key")); 
		
	}
	
	/* translating one line to multiple <NullWritable, BytesWritable> tuples.
	 * Output file is SequenceOutputFile
	 */
	@Override
	public void map(LongWritable key, Text val, Context context) throws IOException, InterruptedException{		
		String[] ss = val.toString().split("\\s+"); 
		byte[] ct; 
		if (MODE_WORD) {
			for (String s : ss) {				
				ct = crypto.encrypt(s);
				BytesWritable bw = new BytesWritable(ct);
				context.write(NullWritable.get(), bw);
			}
		}
		else{ //encrypting the whole line
			int length=0; 
			int t=0; 
			for (String s : ss){
				//the ciphertext length is multiple of AES_BLOCK_SIZE
				if (s.length()%SearchEncryptor.AES_BLOCK_SIZE==0)
					t=s.length()+SearchEncryptor.AES_BLOCK_SIZE; 
				else
					t=(s.length()/SearchEncryptor.AES_BLOCK_SIZE+1)*SearchEncryptor.AES_BLOCK_SIZE; 
								
				length+=t; 
				
			}
			ct = new byte[length+ss.length]; //the ss.length bytes are to store length of each following byte arrays			
			byte[] temp;
			int currentIndex=0; 
			for (String s: ss){
				temp = crypto.encrypt(s); 
				ct[currentIndex]=(byte)temp.length; 
				currentIndex++;
				System.arraycopy(temp, 0, ct, currentIndex, temp.length); 
				currentIndex+=temp.length; 
			}
			context.write(NullWritable.get(), new BytesWritable(ct)); 
		}
	}
}


