package tds.encode.examples;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.conf.Configured;
import org.apache.hadoop.examples.terasort.TeraInputFormat;
import org.apache.hadoop.examples.terasort.TeraOutputFormat;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.NullWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Job;
import org.apache.hadoop.mapreduce.Mapper;
import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;
import org.apache.hadoop.mapreduce.lib.output.SequenceFileOutputFormat;
import org.apache.hadoop.util.Tool;
import org.apache.hadoop.util.ToolRunner;

import tds.ICrypto;
import tds.TdsOptions;
import tds.Utils;
import tds.common.Rand;
import tds.hom.Ope;
import tds.trustedhw.math.CompareFunction;

/**
 * Encrypting data generated by TeraGen (TeraInputFormat), output is TeratOutputFormat:
 * + 20 bytes key
 * + 112 bytes value
 * 
 * In case of TH, the output format is <Text(''), Text(AES of key+value)>
 * 
 */
public class TerasortEncryptor extends Configured implements Tool{

	public static final int PT_KEY_LENGTH=10;
	public static final int PT_VALUE_LENGTH=90;
	
	@Override
	public int run(String[] args) throws Exception {
		Configuration conf = this.getConf(); 
		Job job = new Job(conf); 
		
		job.setJarByClass(TerasortEncryptor.class);
		job.setJobName("OPE encryptor"); 
		job.setMapperClass(OpeMapper.class); 
		job.setNumReduceTasks(0); 
		
		job.setInputFormatClass(TeraInputFormat.class); 
		if (conf.getBoolean(TdsOptions.HOM_OPTION, false))
			job.setOutputFormatClass(TeraOutputFormat.class);		
		else			
			job.setOutputFormatClass(SequenceFileOutputFormat.class); 
		job.setOutputKeyClass(Text.class); 
		job.setOutputValueClass(Text.class); 
		
		FileInputFormat.addInputPath(job, new Path(args[0])); 
		FileOutputFormat.setOutputPath(job, new Path(args[1])); 
				
		return job.waitForCompletion(true)?0: 1;
	}

	static class OpeMapper extends Mapper<Text,Text,Text,Text>{
		ICrypto crypto, auxCrypto; 
		boolean isHom = false;
		int counter = 0; 
		
		@Override
		public void setup(Context context){
			Configuration conf = context.getConfiguration();
			this.isHom = conf.getBoolean(TdsOptions.HOM_OPTION, false); 
			if (this.isHom){
				this.crypto = new Ope();
				this.auxCrypto = new Rand(); 
				this.crypto.initPrivateParameters(Utils.getOpeParams(conf));
				this.auxCrypto.initPrivateParameters(Utils.getSymParams(conf));
			}
			else{
				this.crypto = new CompareFunction(); 						
				this.crypto.initPrivateParameters(Utils.getSymParams(conf)); 
			}
		}
		
		/* input is: 10 bytes key - 90 bytes values
		 */
		@Override
		public void map(Text key, Text val, Context context) throws IOException, InterruptedException{		
			
			byte[] keyVal = key.copyBytes(); 
			byte[] valVal = val.copyBytes(); 
			if (this.isHom){
				Text newKey = new Text(this.crypto.encryptRaw(keyVal));			 
				Text newVal = new Text(this.auxCrypto.encryptRaw(valVal));
				context.write(newKey, newVal); 	
			}
			else{//trusted hardware, encrypt the whole line
				byte[] pt = new byte[keyVal.length+valVal.length]; 
				System.arraycopy(keyVal, 0, pt, 0, keyVal.length);
				System.arraycopy(valVal, 0, pt, keyVal.length, valVal.length); 
				Text newVal = new Text(this.crypto.encryptRaw(pt));
				context.write(new Text(""), newVal); 
			}			 		
			
		}
	}
	
	public static void main(String[] args) throws Exception{
		ToolRunner.run(new TerasortEncryptor(), args); 
	}
}
